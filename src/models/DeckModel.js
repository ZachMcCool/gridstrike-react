/**
 * DeckCard model - represents a card in a deck with quantity
 */
export class DeckCard {
  constructor({ cardId = "", quantity = 1 } = {}) {
    this.cardId = cardId;
    this.quantity = quantity;
  }

  /**
   * Create a DeckCard from API response
   */
  static fromJSON(data) {
    return new DeckCard(data);
  }

  /**
   * Convert to plain object for API requests
   */
  toJSON() {
    return {
      cardId: this.cardId,
      quantity: this.quantity,
    };
  }

  /**
   * Validate the deck card
   */
  isValid() {
    return this.cardId && this.cardId.length > 0 && this.quantity > 0;
  }
}

/**
 * DeckModel - represents a complete deck
 */
export class DeckModel {
  constructor({
    id = null, // Will be generated by Firestore if null
    name = "",
    faction = "",
    cards = [],
  } = {}) {
    this.id = id;
    this.name = name;
    this.faction = faction;
    this.cards = cards.map((card) =>
      card instanceof DeckCard ? card : new DeckCard(card)
    );
  }

  /**
   * Create a DeckModel from API response
   */
  static fromJSON(data) {
    return new DeckModel({
      ...data,
      cards: (data.cards || []).map((card) => new DeckCard(card)),
    });
  }

  /**
   * Convert to plain object for API requests
   */
  toJSON() {
    return {
      id: this.id,
      name: this.name,
      faction: this.faction,
      cards: this.cards.map((card) => card.toJSON()),
    };
  }

  /**
   * Add a card to the deck
   */
  addCard(cardId, quantity = 1) {
    const existingCard = this.cards.find((card) => card.cardId === cardId);
    if (existingCard) {
      existingCard.quantity += quantity;
    } else {
      this.cards.push(new DeckCard({ cardId, quantity }));
    }
  }

  /**
   * Remove a card from the deck
   */
  removeCard(cardId, quantity = null) {
    const cardIndex = this.cards.findIndex((card) => card.cardId === cardId);
    if (cardIndex === -1) return false;

    if (quantity === null) {
      // Remove completely
      this.cards.splice(cardIndex, 1);
    } else {
      // Reduce quantity
      this.cards[cardIndex].quantity -= quantity;
      if (this.cards[cardIndex].quantity <= 0) {
        this.cards.splice(cardIndex, 1);
      }
    }
    return true;
  }

  /**
   * Get total number of cards in deck
   */
  get totalCards() {
    return this.cards.reduce((total, card) => total + card.quantity, 0);
  }

  /**
   * Get unique card count
   */
  get uniqueCards() {
    return this.cards.length;
  }

  /**
   * Check if deck contains a specific card
   */
  hasCard(cardId) {
    return this.cards.some((card) => card.cardId === cardId);
  }

  /**
   * Get quantity of a specific card
   */
  getCardQuantity(cardId) {
    const card = this.cards.find((card) => card.cardId === cardId);
    return card ? card.quantity : 0;
  }

  /**
   * Validate the deck
   */
  isValid() {
    return (
      this.name &&
      this.name.length > 0 &&
      this.cards.every((card) => card.isValid())
    );
  }

  /**
   * Create an empty deck
   */
  static createEmpty(name = "New Deck", faction = "") {
    return new DeckModel({ name, faction });
  }

  /**
   * Clone the deck
   */
  clone() {
    return DeckModel.fromJSON(this.toJSON());
  }
}

export default DeckModel;
